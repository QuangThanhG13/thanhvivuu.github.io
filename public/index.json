[
{
	"uri": "//localhost:1313/4-java_core/4.1-more-question/",
	"title": " More Questions ",
	"tags": [],
	"description": "",
	"content": "Java Core Constructor Constructor là gì: Là phương thức đặc biệt để tạo đối tượng của 1 lớp. Nó có chức năng tạo ra một đối tượng mới của lớp đó và khởi tạo các thuộc tính của đối tượng đó. Có mấy loại constructor: 2 loại: default/no-argument và parameter. Constructor trả về kiểu giá trị gì: Không có kiểu trả về. Constructor có được kế thừa không: Không. Khi tạo lớp con sẽ không kế thừa các constructor của lớp cha ⇒ phải tự định nghĩa constructor riêng của nó. Nếu muốn gọi constructor lớp cha thì phải sử dụng super(). Có thể tạo constructor final không: Không ⇒ Nếu sử dụng sẽ bị lỗi biên dịch. Vì constructor không có hành vi kế thừa như phương thức hoặc lớp, không cần thiết phải sử dụng từ khóa final với constructor. class Person { String name; int age; // Default constructor public Person() { this.name = \u0026#34;Unknown\u0026#34;; this.age = 0; } // Parameterized constructor public Person(String name, int age) { this.name = name; this.age = age; } public void display() { System.out.println(\u0026#34;Name: \u0026#34; + name + \u0026#34;, Age: \u0026#34; + age); } public static void main(String[] args) { Person person1 = new Person(); person1.display(); // Output: Name: Unknown, Age: 0 Person person2 = new Person(\u0026#34;Alice\u0026#34;, 25); person2.display(); // Output: Name: Alice, Age: 25 } } Biến static Biến static là gì: Là biến thuộc về lớp, không thuộc về riêng đối tượng nào cả ⇒ tất cả các đối tượng trong cùng 1 lớp sẽ chia sẻ chung biến static. Biến static chỉ khởi tạo 1 lần khi lớp được nạp vào bộ nhớ. Nó giữ giá trị của nó trong suốt vòng đời của chương trình hoặc khi lớp không còn tồn tại. Ứng dụng: Lưu các giá trị không thay đổi, chẳng hạn như các URL, cấu hình ứng dụng, hoặc thông tin khác cần sử dụng xuyên suốt ứng dụng. class Counter { static int count = 0; public Counter() { count++; } public static int getCount() { return count; } public static void main(String[] args) { Counter c1 = new Counter(); Counter c2 = new Counter(); Counter c3 = new Counter(); System.out.println(\u0026#34;Total objects created: \u0026#34; + Counter.getCount()); // Output: Total objects created: 3 } } Phương thức static Phương thức static là gì: Là phương thức thuộc về lớp, không thuộc về object riêng nào cả. Ứng dụng: Cung cấp các phương thức tiện ích chung không cần truy cập đến trạng thái của đối tượng. class Counter { static int count = 0; public Counter() { count++; } public static int getCount() { return count; } public static void main(String[] args) { Counter c1 = new Counter(); Counter c2 = new Counter(); Counter c3 = new Counter(); System.out.println(\u0026#34;Total objects created: \u0026#34; + Counter.getCount()); // Output: Total objects created: 3 } } Tại sao phương thức main là static? Khi chạy chương trình Java thì JVM cần 1 điểm khởi đầu để bắt đầu thực thi chương trình ⇒ Phương thức main chính là điểm khởi đầu này. JVM không tạo một đối tượng của lớp chứa phương thức main trước khi gọi phương thức đó. Thay vào đó, JVM gọi phương thức main trực tiếp để bắt đầu chương trình. Nếu main không phải là static, JVM sẽ không thể gọi nó mà không có một đối tượng của lớp. Sự khác nhau giữa phương thức static và phương thức instance Phương thức static Phương thức instance Là phương thức thuộc về lớp Là phương thức thuộc về đối tượng cụ thể Được khởi tạo khi lớp được nạp vào bộ nhớ, trước khi bất kỳ đối tượng nào của lớp được tạo ra Được khởi tạo khi một đối tượng của lớp được tạo ra Không phụ thuộc vào bất kỳ đối tượng nào Phụ thuộc vào đối tượng của lớp. Mỗi đối tượng có thể gọi các phương thức instance của chính nó This trong Java là gì? Đại diện cho đối tượng hiện tại của lớp. Dùng để phân biệt biến instance và tham số phương thức có cùng tên. Dùng để gọi các phương thức và constructor khác trong cùng một lớp. Super là gì? Đại diện cho lớp cha của đối tượng hiện tại. Dùng để truy cập các thành phần lớp cha từ lớp con, bao gồm việc gọi phương thức và constructor lớp cha. Có thể sử dụng cả this và super trong 1 constructor không? Có thể, tuy nhiên phải theo thứ tự: super → this. Nếu gọi this trước super → xảy ra lỗi biên dịch. Lớp nào là lớp cha cho tất cả các lớp? Lớp Object. Tất cả các lớp kế thừa từ lớp Object, và do đó, có quyền truy cập vào các phương thức cơ bản mà Object cung cấp. Tại sao đa kế thừa không được hỗ trợ trong Java? Tránh diamond problem. Ví dụ: class C kế thừa từ class A và B. Trong A và B đều có phương thức printInfo() thì C không biết kế thừa từ class nào. Có thể sử dụng interface để thay thế cho đa kế thừa. Sự khác nhau giữa aggregation và composition Aggregation Composition Đối tượng chứa chỉ giữ tham chiếu đến các đối tượng thành phần. Các đối tượng thành phần có thể tồn tại độc lập và có thể được chia sẻ giữa nhiều đối tượng chứa Đối tượng chứa hoàn toàn sở hữu các đối tượng thành phần. Khi đối tượng chứa bị hủy, các đối tượng thành phần cũng bị hủy Mối quan hệ là lỏng lẻo. Đối tượng thành phần có thể tồn tại và được sử dụng bởi nhiều đối tượng chứa khác nhau Mối quan hệ là chặt chẽ. Đối tượng thành phần không thể tồn tại mà không có đối tượng chứa Đối tượng thành phần thường được khởi tạo ngoài constructor của đối tượng chứa và được gán sau Đối tượng thành phần thường được khởi tạo trong constructor của đối tượng chứa Object cloning là gì? Là quá trình tạo ra 1 bản sao của đối tượng. Quá trình này tạo ra một đối tượng mới với các giá trị giống hệt đối tượng gốc, nhưng có tham chiếu (reference) khác. Có 2 cách để thực hiện cloning: Sử dụng Cloneable Interface và Object.clone() Method. Sử dụng Constructor sao chép hoặc Phương Thức sao chép. Mục đích: Clone giúp tạo ra các bản sao của đối tượng để làm việc hoặc thử nghiệm mà không ảnh hưởng đến đối tượng gốc. Overloading phương thức là gì? Là một tính năng trong Java cho phép một lớp có nhiều phương thức cùng tên nhưng khác nhau về danh sách tham số (số lượng hoặc kiểu tham số). Overloading không phụ thuộc vào kiểu trả về của phương thức, nghĩa là không thể tạo ra nhiều phương thức chỉ khác nhau về kiểu trả về. Điều này giúp tạo nhiều phương thức có cùng 1 tên nhưng có thể xử lý các kiểu dữ liệu khác nhau/số lượng tham số khác nhau. Tại sao overloading phương thức không xảy ra khi thay đổi kiểu giá trị trả về? Vì điều này gây ra sự không rõ ràng trong việc chọn phương thức khi gọi.\nVí dụ: lúc này nếu gọi phương thức add thì sẽ không biết gọi cái nào ⇒ lỗi biên dịch method add(int,int) is already defined in class Example.\nclass Example { // Phương thức 1 public int add(int a, int b) { return a + b; } // Phương thức 2 public double add(int a, int b) { return a + b + 0.5; } } Có thể overload phương thức main không? Có thể, tuy nhiên khi chạy ứng dụng JVM chỉ gọi phương thức main(String[] args) và bỏ qua các phiên bản overload khác. Ghi đè phương thức là gì? Là kỹ thuật cho phép lớp con kế thừa phương thức từ lớp cha và thay đổi hành vi của nó để phù hợp với nhu cầu cụ thể. Quy tắc: Phương thức ghi đè phải có cùng chữ ký với phương thức trong lớp cha. Không thể có phạm vi truy cập chặt chẽ hơn. Không thể là static. Các phương thức final, static, và private không thể bị ghi đè. Tại sao không thể ghi đè phương thức static? Vì phương thức static thuộc về class chứ không thuộc về đối tượng. Có thể ghi đè phương thức đã nạp chồng không? Có thể, phương thức ghi đè trong lớp con phải có cùng chữ ký với phương thức trong lớp cha mà nó ghi đè. Có thể ghi đè biến instance không? Không thể ghi đè các biến instance. Nếu lớp con định nghĩa một biến với cùng tên như trong lớp cha, biến này sẽ ẩn biến của lớp cha nhưng không thay thế nó. Biến trong lớp con và lớp cha vẫn tồn tại độc lập và có thể được truy cập dựa trên tham chiếu đối tượng. Sự khác nhau giữa overload và override Overload Override Xảy ra trong cùng 1 lớp hoặc lớp con Xảy ra khi lớp con định nghĩa phương thức với cùng tên và danh sách tham số như phương thức trong lớp cha Các phương thức phải có cùng tên nhưng khác nhau về danh sách tham số Phương thức phải có cùng chữ ký với phương thức cha Không liên quan đến kế thừa, không thay thế phương thức Có liên quan đến kế thừa, thay thế hành vi của phương thức trong lớp cha Kiểu trả về hiệp biến là gì? Là khả năng của phương thức ghi đè trong lớp con để trả về một kiểu dữ liệu con của kiểu dữ liệu trả về trong phương thức lớp cha. Biến/phương thức/class final là gì? Biến final: Biến Instance/Static: Giá trị không thể thay đổi sau khi được gán. Biến Cục Bộ: Không thể gán lại giá trị sau lần gán đầu tiên. Phương thức final: Không thể ghi đè. Tăng hiệu năng khi không cần phải kiểm tra ghi đè. Class final: Không thể tạo lớp con. Bảo vệ class khỏi sự thay đổi. final class Constants { public static final int MAX_AGE = 100; } class TestFinal { public static void main(String[] args) { // Constants.MAX_AGE = 120; // Error: Cannot assign a value to final variable \u0026#39;MAX_AGE\u0026#39; System.out.println(Constants.MAX_AGE); // Output: 100 } } Interface là gì? Là một bộ quy tắc (contracts) mà các lớp phải tuân theo. Nó chỉ định các phương thức mà một lớp phải triển khai mà không cung cấp bất kỳ thực thi nào. Ứng dụng: Định nghĩa các chức năng cơ bản mà các lớp cần tuân theo. Cho phép tạo ra các hệ thống linh hoạt và dễ mở rộng. Abstract class là gì? Là một lớp không thể tạo ra đối tượng từ nó, chỉ có thể được kế thừa. Nó có thể có cả phương thức abstract (không có thân phương thức) và non-abstract. Ứng dụng: Dùng khi có một số hành vi chung mà các lớp con có thể chia sẻ, nhưng các lớp con cũng cần triển khai các phương thức cụ thể riêng của mình. // Interface interface AnimalInterface { void eat(); void sleep(); } // Abstract class abstract class AnimalAbstract { abstract void eat(); void sleep() { System.out.println(\u0026#34;Sleeping\u0026#34;); } } // Implementing interface class Dog implements AnimalInterface { public void eat() { System.out.println(\u0026#34;Dog is eating\u0026#34;); } public void sleep() { System.out.println(\u0026#34;Dog is sleeping\u0026#34;); } } // Extending abstract class class Cat extends AnimalAbstract { void eat() { System.out.println(\u0026#34;Cat is eating\u0026#34;); } } public class Main { public static void main(String[] args) { Dog dog = new Dog(); dog.eat(); // Output: Dog is eating dog.sleep(); // Output: Dog is sleeping Cat cat = new Cat(); cat.eat(); // Output: Cat is eating cat.sleep(); // Output: Sleeping } } String là gì? Tại sao String là bất biến (immutable)? String là một lớp đặc biệt trong Java để lưu trữ và xử lý chuỗi văn bản. Bất biến (immutable): Mỗi khi thao tác trên String, một đối tượng mới được tạo ra thay vì thay đổi đối tượng hiện tại. Điều này giúp tăng cường bảo mật và hiệu suất. Khác nhau giữa lớp String, StringBuffer và StringBuilder String: Bất biến (immutable), an toàn cho việc sử dụng trong môi trường đa luồng, nhưng tốn bộ nhớ hơn khi thực hiện nhiều thao tác. StringBuffer: Có thể thay đổi (mutable), an toàn cho việc sử dụng trong môi trường đa luồng, hiệu năng thấp hơn StringBuilder. StringBuilder: Có thể thay đổi (mutable), không an toàn cho việc sử dụng trong môi trường đa luồng, hiệu năng cao hơn StringBuffer. public class StringExample { public static void main(String[] args) { // Immutable String String str = \u0026#34;Hello\u0026#34;; str = str.concat(\u0026#34; World\u0026#34;); System.out.println(str); // Output: Hello World // StringBuffer (Thread-safe) StringBuffer sb = new StringBuffer(\u0026#34;Hello\u0026#34;); sb.append(\u0026#34; World\u0026#34;); System.out.println(sb); // Output: Hello World // StringBuilder (Not thread-safe, but faster) StringBuilder sbuilder = new StringBuilder(\u0026#34;Hello\u0026#34;); sbuilder.append(\u0026#34; World\u0026#34;); System.out.println(sbuilder); // Output: Hello World } } Sự khác nhau giữa equals() và == trong Java equals() so sánh nội dung của hai đối tượng (method này có thể được override trong các class để định nghĩa cách so sánh cụ thể). == so sánh tham chiếu (reference) của hai đối tượng, tức là kiểm tra xem hai đối tượng có cùng tham chiếu đến cùng một vùng nhớ hay không. class Person { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null || getClass() != obj.getClass()) return false; Person person = (Person) obj; return age == person.age \u0026amp;\u0026amp; name.equals(person.name); } @Override public int hashCode() { return Objects.hash(name, age); } public static void main(String[] args) { Person p1 = new Person(\u0026#34;John\u0026#34;, 25); Person p2 = new Person(\u0026#34;John\u0026#34;, 25); System.out.println(p1.equals(p2)); // Output: true } } Có thể ghi đè phương thức equals() không? Có thể ghi đè phương thức equals() để định nghĩa cách so sánh nội dung của hai đối tượng. Tuy nhiên, khi ghi đè equals(), cần phải tuân thủ hợp đồng (contract) của phương thức này, như: tính đối xứng, tính phản xạ, và tính chuyển tiếp. Phương thức hashCode() là gì? Là phương thức trả về một giá trị số nguyên (hash code) biểu diễn cho đối tượng, được sử dụng chủ yếu trong các cấu trúc dữ liệu như HashMap, HashSet. Ghi đè hashCode() khi ghi đè equals(): Để đảm bảo rằng hai đối tượng bằng nhau theo phương thức equals() thì cũng phải có cùng giá trị hashCode(). So sánh interface và abstract class Interface Abstract class Chỉ có thể chứa phương thức abstract và thuộc tính tĩnh (static). Từ Java 8 trở đi, có thể có phương thức default và static với thân phương thức Có thể chứa cả phương thức abstract và non-abstract Không có constructor Có constructor Một lớp có thể implement nhiều interface Một lớp chỉ có thể kế thừa từ một abstract class Tất cả các phương thức đều ngầm định là public và abstract (trước Java 8) Các phương thức có thể có bất kỳ phạm vi truy cập nào Các thuộc tính ngầm định là public, static và final Có thể có các thuộc tính instance không phải final Boxing/unboxing là gì? Boxing là quá trình chuyển đổi kiểu dữ liệu nguyên thủy (primitive type) thành đối tượng của lớp wrapper tương ứng (e.g., int → Integer). Unboxing là quá trình ngược lại, chuyển đổi đối tượng của lớp wrapper thành kiểu dữ liệu nguyên thủy. Ví dụ: int (kiểu nguyên thủy) -\u0026gt; Integer (lớp wrapper). public class BoxingUnboxing { public static void main(String[] args) { // Boxing: converting primitive to wrapper object int num = 5; Integer boxedNum = num; // Autoboxing // Unboxing: converting wrapper object to primitive Integer obj = new Integer(10); int unboxedNum = obj; // Auto-unboxing System.out.println(\u0026#34;Boxed: \u0026#34; + boxedNum); // Output: Boxed: 5 System.out.println(\u0026#34;Unboxed: \u0026#34; + unboxedNum); // Output: Unboxed: 10 Chuyển kiểu tường minh (type casting) Là quá trình chuyển đổi một kiểu dữ liệu này thành kiểu dữ liệu khác theo yêu cầu của lập trình viên. Upcasting Chuyển từ kiểu con thành kiểu cha. Cú pháp: ClassCha obj = (ClassCha) objCon. Downcasting Chuyển từ kiểu cha thành kiểu con.\nCú pháp: ClassCon obj = (ClassCon) objCha.\nKhi sử dụng downcasting, cần kiểm tra kiểu dữ liệu bằng toán tử instanceof để đảm bảo an toàn.\nStatic binding vs Dynamic binding Static binding: Xảy ra trong thời gian biên dịch. Sử dụng cho phương thức static, final, và private. Dynamic binding: Xảy ra trong thời gian chạy. Sử dụng cho các phương thức instance và override. class StaticBindingExample { private void display() { System.out.println(\u0026#34;Static Binding Example\u0026#34;); } public static void main(String[] args) { StaticBindingExample obj = new StaticBindingExample(); obj.display(); // Output: Static Binding Example (Resolved at compile-time) } } class Animal { void sound() { System.out.println(\u0026#34;Animal sound\u0026#34;); } } class Dog extends Animal { @Override void sound() { System.out.println(\u0026#34;Dog barks\u0026#34;); } public static void main(String[] args) { Animal obj = new Dog(); obj.sound(); // Output: Dog barks (Resolved at runtime) } } Các thành phần trong OOP Inheritance: Kế thừa tính năng của lớp cha. Polymorphism: Đa hình, tức là cùng một hành vi có thể có nhiều hình thức khác nhau. Encapsulation: Đóng gói, tức là ẩn giấu các chi tiết thực hiện và chỉ cung cấp những thông tin cần thiết ra bên ngoài. Abstraction: Trừu tượng hóa, tức là chỉ giữ lại những thông tin quan trọng và ẩn đi các chi tiết phức tạp. "
},
{
	"uri": "//localhost:1313/2-git/2.1-gitbasic/",
	"title": "Basic Git repository",
	"tags": [],
	"description": "",
	"content": "Theory GitHub Basics Introduction to Git and GitHub Git is a free and open-source distributed version control system.\nGitHub is a code hosting platform for version control and collaboration.\nBasic Git Concepts Version Control:\nTracks changes to the source code.\nStores different versions of the code.\nAllows rollback to old versions for inspection and bug fixes.\n2Repository (Repo):\nA place where all files and the history of changes are stored.\nCan be stored locally or on services like GitHub.\nBasic Git Commands git init: Initialize a new repository.\ngit add \u0026lt;file\u0026gt;: Add a new file to the repository.\ngit commit -m \u0026quot;message\u0026quot;: Commit changes with a message.\ngit remote add origin \u0026lt;url\u0026gt;: Add a remote repository.\ngit push origin \u0026lt;branch\u0026gt;: Push commits to the remote repository.\ngit pull origin \u0026lt;branch\u0026gt;: Pull changes from the remote repository.\ngit status: Check the status of the repository.\ngit log: View commit history.\nUsing GitHub Pull source code from thanhvivuu.GitHub\nStep 1 : Clone the repository Open terminal :\ngit clone https://github.com/QuangThanhG13/thanhvivuu.github.io Step 2 : Change to the directory cd : thanhvuu.github.io Step 3 : Create a new Branch (Optional) If you want to work on a new feature or make changes without affecting the existing code, create a new(Khong anh hg den code cu) branch to isolate your work git checkout -b new-feature-branch Step 4 Check the Status git status Step 5 :Stage the Changes Add the modified files git add . Or add specific files git add path/to/file Step 6 : commit the changes git commit -m \u0026#34;massage\u0026#34; Step 7 : Push the changes git push origin main if you\u0026rsquo;re using a new branch: git push origin new-branch-name "
},
{
	"uri": "//localhost:1313/3-shopapp/3.1--design-my-sql/",
	"title": "Design my SQL",
	"tags": [],
	"description": "",
	"content": "Thiết Kế database cho Shop app 1. Một số lý thuyết quan trọng khi sử dung Design id int PRIMARY KEY AUTO_INCREMENT, : Đây là trường id khóa chính và tự động tăng giá trị. is_active TINYINT(1) DEFAULT 1, : Đây dùng để hiểu là thanh trạng thái hoạt động hoặc đang tắt hoạt động Trong bảng tokens : expiration_date DATETIME : cột này để lưu thời gian hết hạn của token. revoked TINYINT(1) NOT NULL :cột này đánh dấu xem token đã hết hạn hay chưa, token đã bị thu hồi trước khi hết hạn. expired TINYINT(1) NOT NULL : tương tự cột revoked,giá trị 0 có thể biểu thị chưa hết hạn, và 1 biểu thị đã hết hạn, token đã hết hạn theo thời gian. Trong bảng products FOREIGN KEY (category_id) REFERENCES categories(id) Quan hệ một nhiều điêù này nghĩa là category trong bảng product đúng là id trong bảng categories.\nBảng categories (danh mục sản phẩm):\nid name 1 Electronics 2 Clothing 3 Books Bảng products (sản phẩm):\nid name price category_id 1 Laptop 1000 1 2 T-Shirt 20 2 3 Novel 15 3 4 Smartphone 700 1 TIMESTAMP có ưu điểm là tự động cập nhật và chuyển đổi múi giờ, phù hợp để theo dõi thời gian trong hệ thống.\nNếu muốn thêm một cột sau khi tạo rồi thì dùng ALTER: ALTER TABLE orders ADD COLUMN `shipping_method` VARCHAR(100); ALTER TABLE orders ADD COLUMN `shipping_address` VARCHAR(200); ALTER TABLE orders ADD COLUMN `shipping_date` DATE; ALTER TABLE orders ADD COLUMN `tracking_number` VARCHAR(100); ALTER TABLE orders ADD COLUMN `payment_method` VARCHAR(100); --xóa 1 đơn hàng =\u0026gt; xóa mềm =\u0026gt; thêm trường active ALTER TABLE orders ADD COLUMN active TINYINT(1); --Trạng thái đơn hàng chỉ đc phép nhận \u0026#34;một số giá trị cụ thể\u0026#34; ALTER TABLE orders MODIFY COLUMN status ENUM(\u0026#39;pending\u0026#39;, \u0026#39;processing\u0026#39;, \u0026#39;shipped\u0026#39;, \u0026#39;delivered\u0026#39;, \u0026#39;cancelled\u0026#39;) COMMENT \u0026#39;Trạng thái đơn hàng\u0026#39;; "
},
{
	"uri": "//localhost:1313/1-introduce/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Introduction to CI/CD, Jenkins and ArgoCD CI/CD stands for Continuous Integration/Continuous Delivery or Continuous Deployment. This is a software development approach aimed at automating the integration, testing, delivery, and deployment processes of applications.\nCI/CD continuously tests new code commits. This helps to prevent errors in the system before the new code is updated on the server. Regular integration and testing help identify and fix errors early, avoiding major problems in later stages. CI/CD automates the development and deployment processes, helping teams accelerate the release of new products.\nPopular tools that support CI/CD include Jenkins, GitLab CI, Travis CI, CircleCI, and ArgoCD for Kubernetes. Typically, what is used the most is:\nJenkins: an open-source tool that automates software development tasks such as build, test, and deploy. ArgoCD is a continuous orchestration tool for Kubernetes, helping to automate the deployment of applications in microservices architecture and manage multiple Kubernetes environments consistently. This approach not only improves team performance but also enables your product to reach users more quickly and with higher quality. In the cloud computing environment, developers often use Docker to package and Kubernetes to orchestrate.\nContents The CI/CD operations process Jenkins ArgoCD In the following sections, we will delve into the fundamental concepts of CI/CD, Jenkins and ArgoCD.\n"
},
{
	"uri": "//localhost:1313/1-introduce/1.1-cicdprocess/",
	"title": "The CI/CD operations process",
	"tags": [],
	"description": "",
	"content": "The CI/CD operations process To gain a deeper understanding of how the CI/CD process works, one needs to grasp the specific steps involved. So what do these steps include, and how do they function?\nContinuous Integration (CI) is the first process, where developers frequently merge their code into a common repository such as Git, multiple times a day. Each merge is often automatically built and tested to detect errors as early as possible, minimizing bug accumulation and reducing the time needed to deliver high-quality products. Continuous Delivery (CD) extends CI by ensuring that you can release a new version of the software at any time. In CD, the processes of building, testing, and preparing code for release are automated. Continuous Deployment (CD) is a further step beyond CD, where tested changes to the code are automatically released into the production environment. This ensures that any change, once verified, can be deployed automatically. The development lifecycle process along with the steps in CI/CD occur as follows:\nBuild: Create products from the source code, integrate, and detect errors. Test: Automatically examine new features and changed code. Deliver: Move tested code to a test environment, which can be automatic or after human approval. Deploy: Implement changes to the product, automatically or according to human approval. "
},
{
	"uri": "//localhost:1313/1-introduce/1.4-docker/",
	"title": "Theory Docker Project",
	"tags": [],
	"description": "",
	"content": "Theory Docker Project Introduction to Docker Docker is an open-source platform that automates the deployment Docker packages your application and all its dependencies into an image. A Docker image contains everything needed to run your application Key Concepts Containers: Containers are lightweight, portable, and run isolated processes on a shared operating system. They contain everything needed to run an application, including code, runtime, libraries, and settings. )\nImages: Images are read-only templates used to create containers. They are built from a Dockerfile and include the application code, dependencies, and the runtime environment.\nDockerfile: A Dockerfile is a script containing instructions on how to build a Docker image. It specifies the base image, application code, environment variables, and commands to run.\nDocker Hub: Docker Hub is a cloud-based repository where users can find and share Docker images. It provides a centralized place to store and manage Docker images.\nAdvantages of Docker Portability: Containers can run on any system with Docker installed, ensuring consistent behavior across development, testing, and production environments. Efficiency: Containers share the host system\u0026rsquo;s kernel, making them more lightweight and efficient compared to virtual machines. Scalability: Docker enables easy scaling of applications by deploying multiple containers across various environments. Isolation: Containers run in isolated environments, preventing conflicts between applications and enhancing security. Docker Architecture Docker Engine: The core component of Docker, responsible for creating and managing containers. It consists of:\nDocker Daemon: The background service running on the host machine that manages Docker objects (images, containers, networks, volumes). Docker CLI: The command-line interface used to interact with the Docker Daemon. Docker Objects:\nImages: Immutable files used to create containers. Containers: Running instances of images that can be started, stopped, moved, and deleted. Networks: Enable communication between Docker containers. Volumes: Provide persistent storage for containers. Basic Docker Commands docker run: Create and start a new container from an image. docker build: Build an image from a Dockerfile. docker pull: Download an image from a registry. docker push: Upload an image to a registry. docker ps: List running containers. docker stop: Stop a running container. docker rm: Remove a container. docker rmi: Remove an image. Example: Creating a Docker Image Here\u0026rsquo;s an example of a simple Dockerfile to create a Docker image for a Python application:\n# Use the official Python base image FROM python:3.8-slim # Set the working directory WORKDIR /app # Copy the current directory contents into the container COPY . /app # Install any needed packages specified in requirements.txt RUN pip install --no-cache-dir -r requirements.txt # Make port 80 available to the world outside this container EXPOSE 80 # Define the command to run the application CMD [\u0026#34;python\u0026#34;, \u0026#34;app.py\u0026#34;] "
},
{
	"uri": "//localhost:1313/2-git/",
	"title": "Advanced Git",
	"tags": [],
	"description": "",
	"content": "Advanced Git 1. Advanced Branching and Merging Branching Strategy: Branching strategies like Git Flow, GitHub Flow, and Trunk-based Development help organize and manage the development process. Rebase: Used to move or combine a series of commits from one branch to another. Rebase makes the commit history cleaner by removing unnecessary merge commits. Cherry-pick: Selectively apply a commit from one branch to another without merging the entire branch. Merge Conflicts: How to resolve merge conflicts and use tools like git mergetool. 2. Advanced Git Commands and Usage Stash: Save unfinished changes without committing them, allowing you to switch to other tasks. Use git stash apply or git stash pop to restore stashed changes. Bisect: Locate bugs by bisecting the commit range to find the offending commit. Filter-branch and BFG: Modify commit history, such as removing large files or sensitive information that was previously committed. 3. Git Hooks Git hooks are scripts that execute automatically when certain events occur in Git, such as commit, push, or merge. Common hooks include:\nPre-commit: Check the source code before committing. Pre-push: Validate or execute actions before pushing to a remote. Post-checkout: Execute after a new branch is checked out. 4. Managing Large Repositories and Advanced Techniques Shallow Clone: Clone a repository with limited depth to reduce time and storage space. Sparse Checkout: Allows downloading only a portion of the repository, useful for projects with large directory structures. Large File Storage (LFS): Used to manage large binary files that Git doesn\u0026rsquo;t handle well. 5. Security and Access Control GPG Commit Signing: Sign commits to ensure authenticity. Access Control: Manage repository access permissions through platforms like GitHub, GitLab, or Bitbucket. 6. Performance Optimization Garbage Collection: Use git gc to clean up and optimize storage space. Submodules: Manage sub-repositories within a main repository. Subtree: An alternative to submodules, allowing the management of code from external repositories. 7. External Tools and Utilities Git GUI Tools: Graphical interface tools like SourceTree, GitKraken, and GitHub Desktop help manage repositories and workflows more easily. Continuous Integration (CI): Integrate Git with CI/CD services like Jenkins, GitLab CI, and GitHub Actions to automate testing and deployment. 8. Best Practices Commit Messages: Write clear and meaningful commit messages. Branch Naming Conventions: Use branch naming conventions for easy management and tracking. Code Reviews: Conduct code reviews before merging into the main branch. "
},
{
	"uri": "//localhost:1313/2-git/2.2-advancedgit/_index1/",
	"title": "GH flow",
	"tags": [],
	"description": "",
	"content": "Examples of Branching Strategies 1. Git Flow Example Scenario: A development team is preparing to release version 1.0 of an application.\nMain Branch (main): Contains the stable, released version of the application.\nDevelop Branch (develop): Contains the latest development changes for the next release.\nSteps:\nFeature Branches:\nfeature/user-authentication: A developer creates this branch from develop to add user authentication functionality.\nfeature/payment-integration: Another developer creates this branch from develop to add payment integration.\nMerging Features:\nAfter completing and testing features, they are merged into develop. Release Branch:\nWhen features are ready for release, a release/1.0 branch is created from develop. This branch is used for final bug fixes and release preparation.\nOnce ready, release/1.0 is merged into both main and develop, updating the official release and ensuring bug fixes are also in the development branch.\nHotfix Branch:\nIf an urgent issue needs fixing in version 1.0, a hotfix/1.0.1 branch is created from main, the issue is fixed, and the branch is merged into both main and develop. 2. GitHub Flow Example Scenario: A development team is adding an \u0026ldquo;About Us\u0026rdquo; page to the company\u0026rsquo;s website.\nSteps:\nCreate a Branch:\nA developer creates the add-about-page branch from main to work on the \u0026ldquo;About Us\u0026rdquo; page. Make Changes:\nOn the add-about-page branch, the developer adds HTML and CSS files for the \u0026ldquo;About Us\u0026rdquo; page. Each significant change is committed and pushed with descriptive messages like add initial about page content and style about page. Create a Pull Request:\nUpon completion, the developer creates a pull request from add-about-page to main, describing the changes and their purpose. They also link the pull request to a relevant issue. Review and Feedback:\nColleagues review the pull request, leaving comments or suggestions. The developer may make additional commits to address the feedback. Merge and Deploy:\nOnce the pull request is approved, it is merged into main, and the changes are deployed to the website. Delete the Branch:\nAfter merging, the add-about-page branch is deleted to avoid confusion with other ongoing work. 3. Trunk-Based Development Example Scenario: A company continuously develops a web application with frequent feature additions.\nSteps:\nDirect Commits to Trunk (main):\nAll developers work directly on the main branch, committing small, frequent changes. Short-lived Feature Branches:\nIf necessary, developers can create short-lived feature branches (e.g., feature/update-dashboard) for complex features but must complete and merge them back into main quickly. Continuous Integration:\nEach commit to main triggers an automatic CI process, running tests and deploying changes if all tests pass. Feature Flags:\nIncomplete new features are hidden behind feature flags, allowing them to be deployed without impacting users. Summary:\nIn Trunk-Based Development, the main branch is always kept stable and deployable. Features and bug fixes are integrated continuously and quickly.\n"
},
{
	"uri": "//localhost:1313/2-git/2.2-advancedgit/_index2/",
	"title": "GibHub homework",
	"tags": [],
	"description": "",
	"content": "Advanced Exercise: Project Management with Git Step 1: Install Git Go to git-scm.com. Download and install Git following the instructions for your operating system. Step 2: Configure Git Open the terminal (or Command Prompt on Windows). Configure your name and email with the following commands: git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34; Step 3: Initialize a Repository Create a new directory and move into it: mkdir AdvancedGitProject cd AdvancedGitProject Initial a git repository git init git init is used to initialize a new Git repository Creates a .git Directory Prepares the Project for Version Control : Flow the changes from the Sets Up the Initial Branch: By default, git init \u0026ndash;\u0026gt; creates a new branch called main Step 4: Add and Commit Changes Create a README.md file and add a description: echo \u0026#34;# AdvancedGitProject\u0026#34; \u0026gt;\u0026gt; README.md Add and commit the changes: git add README.md git commit -m \u0026#34;Add README file\u0026#34; Step 5: Create a New Branch and Use Rebase Create and switch to a new branch: git checkout -b feature-branch Create a feature.txt file, add content, and commit the changes echo \u0026#34;This is a new feature\u0026#34; \u0026gt;\u0026gt; feature.txt git add feature.txt 3. Switch back to the main branch\ngit checkout main Create a hotfix.txt file, add content, and commit the changes: echo \u0026#34;This is a hotfix\u0026#34; \u0026gt;\u0026gt; hotfix.txt git add hotfix.txt git commit -m \u0026#34;Add hotfix.txt\u0026#34; 5.Rebase the feature-branch onto the main branch:\ngit checkout feature-branch git rebase main git rebase main: Rebase nhánh feature-branch lên nhánh main có nghĩa là: Lấy tất cả các commit từ nhánh feature-branch và áp dụng chúng lên đỉnh của nhánh main. Cập nhật nhánh feature-branch với các thay đổi mới nhất từ nhánh main. Đảm bảo rằng các thay đổi trên nhánh feature-branch được áp dụng sau các thay đổi trên nhánh main, giúp lịch sử commit của nhánh feature-branch trở nên đồng bộ với nhánh main. -Create files here Nghĩa là sẽ lấy commit từ nhanh feature-branch này cập nhập vào nhánh main. Lý Thuyết Git reabse Được hiểu như là Reset base cho barch, giả sử mình có 1 nhánh feature/crawl_video_links Step 6: User Cherry picks Create a new commit on the main branch git checkout main echo \u0026#34;Another fix\u0026#34; \u0026gt;\u0026gt; anotherfix.txt git add anotherfix.txt git commit -m \u0026#34;Add anotherfix.txt\u0026#34; Cherry-pick this commit onto the feature-branch: git checkout feature-branch git cherry-pick \u0026lt;commit-hash\u0026gt; Trong hình cho ta thấy git cherry-pick ed7bb320f46b3b3842174c661c88e2e3ab120ded dùng để chọn và áp dụng một commit từ một nhánh khác vào nhánh hiện tại. tôi đã tạo file anotherfix.text ở nhanh main và sử dụng git cherry-pick ... để chuyển sang nhánh feature Step 7: Use Stash Make some changes on the feature-branch that you don\u0026rsquo;t want to commit yet echo \u0026#34;Some temporary changes\u0026#34; \u0026gt;\u0026gt; temp.txt Stash the changes: git stash Perform other tasks: git checkout main echo \u0026#34;Work on another task\u0026#34; \u0026gt;\u0026gt; another_task.txt git add another_task.txt git commit -m \u0026#34;Work on another task\u0026#34; Retrieve the changes from the stash git checkout feature-branch git stash pop Nếu mình chưa muốn commit vào file thì sử dụng git stash git stash: Lưu trữ các thay đổi chưa được commit để quay lại làm việc sau. git stash pop: Lấy lại các thay đổi từ stash và áp dụng chúng lên nhánh hiện tại. git stash list: Xem danh sách các mục stash hiện có. Step 8 : Use Submodule Add a submodule to your project (e.g., add a repository from GitHub): git submodule add \u0026lt;repository-url\u0026gt; Step 9: Push to GitHub Push your changes to GitHub git remote add origin \u0026lt;repository-url\u0026gt; git branch -M main git push -u origin main Rebase Git 9000 steps Target Change to Step: $ git checkout bugFix $ git rebase main $ git checkout side $ git rebase bugFix $ git check another $ git rebase bugFix $ git rebase another main "
},
{
	"uri": "//localhost:1313/3-shopapp/3.2-java-spring-boot-backendp1/",
	"title": "Java Spring Boot backend (p1)",
	"tags": [],
	"description": "",
	"content": "Java Spring Boot backend (P1) Đối với class Category 1. Lý thuyết Một số lý thuyết về anotation @RequestBody : Được hiểu như là nó sẽ chạy vào body khi mình truyền vào gì @RequestParam : Mình chuyền vào cái gì @NotNull : từ chối giá trị null hoặc không có nhưng chấp nhận giá trị rỗng(empty). @NotEmpty : cả giá trị null lẫn giá trị rỗng bằng cách kiểm tra độ dài (length) (String) hoặc kích thước (size) (Collection) xem có lớn hơn 0 hay không. @NotBlank : Annotation này từ chối String có giá trị null và String có độ dài là 0 sau khi đã trim (loại bỏ hết khoảng trắng thừa ở đầu và cuối của String) 2. Giải thích 3. Một số lỗi thường gặp Hiễn mã lỗi trong posman Khi chưa fix lỗi\nTrường hơpj là name = empty, nhưng trong package dtos có annotation NOTEMPTY public ResponseEntity\u0026lt;String\u0026gt; insertCategory(@Valid @RequestBody CategoryDTO categoryDTO) { return ResponseEntity.ok(\u0026#34;Insert category thành công: \u0026#34; + categoryDTO); } Tôi muốn hiện ra như này\nsửa đoạn code public ResponseEntity\u0026lt;?\u0026gt; insertCategory( // Nếu chuyển ?--\u0026gt; sang kiểu string thì nó không nhận , vậy phải để kiểu ? để nó nhận thêm kiểu (List và String) @Valid @RequestBody CategoryDTO categoryDTO, BindingResult result) { if (result.hasErrors()) { String errorMessages = String.valueOf(result.getFieldErrors() .stream() .map(FieldError::getDefaultMessage) .toList()); return ResponseEntity.badRequest().body(errorMessages); } return ResponseEntity.ok(\u0026#34;Insert category thành công: \u0026#34; + categoryDTO); } Lưu ý: phải xóa anotation @Validated đi bởi vì khi chạy vào class nó sẽ tự hiểu chạy vào annotation này mà không valid ở trên Nó sẽ hiễn mã lỗi 500\nXử lý lỗi xác thực bằng BindingResult BingdingResult là nơi mà spring chứa xác thực dữ liệu Nếu như có lỗi xác thực đầu vào thì ta dùng BindingResult.hasErrors(): @PostMapping(consumes = MediaType.APPLICATION_JSON_VALUE) public String createPerson(@RequestBody @Valid PersonRequest request, BindingResult bindingResult) { if (bindingResult.hasErrors()) { return \u0026#34;Một hoặc nhiều trường truyền vào không hợp lệ!\u0026#34;; } } Các này sẽ không biết cái cụ thể trường nào lỗi và vì sao lại lỗi.\nKhắc phục chúng ta dùng : BindingResult.getFieldErrors để lấy tất cả các trường bị lỗi bao gồm cả message. @PostMapping(consumes = MediaType.APPLICATION_JSON_VALUE) public String createPerson(@RequestBody @Valid PersonRequest request, BindingResult bindingResult) { if(bindingResult.hasErrors()){ Map\u0026lt;String, String\u0026gt; errors= new HashMap\u0026lt;\u0026gt;(); // Quan Trọng vì cái này sẽ lưu các trường vào đây bindingResult.getFieldErrors().forEach( error -\u0026gt; errors.put(error.getField(), error.getDefaultMessage()) ); String errorMsg= \u0026#34;\u0026#34;; for(String key: errors.keySet()){ errorMsg+= \u0026#34;Lỗi ở: \u0026#34; + key + \u0026#34;, lí do: \u0026#34; + errors.get(key) + \u0026#34;\\n\u0026#34;; } return errorMsg; } //TODO: Thêm code gọi xuống service layer log.info(request.toString()); return \u0026#34;Các trường truyền vào hợp lệ!\u0026#34;; } Nếu muốn custome mã lỗi riêng thì ta làm như sau @Documented @Constraint(validatedBy = CapitalizedValidator.class) @Target( { ElementType.METHOD, ElementType.FIELD }) @Retention(RetentionPolicy.RUNTIME) public @interface CapitalizedConstraint { String message() default \u0026#34;Chữ đầu tiên phải được in hoa!\u0026#34;; Class\u0026lt;?\u0026gt;[] groups() default {}; Class\u0026lt;? extends Payload\u0026gt;[] payload() default {}; } public class CapitalizedValidator implements ConstraintValidator\u0026lt;CapitalizedConstraint, String\u0026gt; { @Override public void initialize(CapitalizedConstraint constraintAnnotation) { ConstraintValidator.super.initialize(constraintAnnotation); } @Override public boolean isValid(String value, ConstraintValidatorContext context) { if(!StringUtils.hasLength(value)) return Boolean.FALSE; if(!Character.isUpperCase(value.charAt(0))) return Boolean.FALSE; return Boolean.TRUE; } } Cuối cùng ta thêm annotation vào private String name; "
},
{
	"uri": "//localhost:1313/1-introduce/1.2-jenkins/",
	"title": "Jenkins",
	"tags": [],
	"description": "",
	"content": "Jenkins Jenkins is an open-source automation tool that helps to automate various parts of the software development process such as building, testing, and deploying applications. It supports Continuous Integration (CI) and Continuous Delivery (CD).\nYou can use Amazon Elastic Compute Cloud (Amazon EC2) to deploy a Jenkins application on AWS in a matter of minutes.\nThis tutorial walks you through the process of deploying a Jenkins application. You will launch an EC2 instance, install and configure Jenkins on that instance.\n"
},
{
	"uri": "//localhost:1313/1-introduce/1.3-argocd/",
	"title": "Argo CD",
	"tags": [],
	"description": "",
	"content": "Argo CD Argo CD is an open-source project designed to provide automated deployment for Kubernetes projects. It follows the \u0026ldquo;GitOps\u0026rdquo; principle, automatically synchronizing Kubernetes projects to match the source code in the git repository. Simply commit changes to git, and Argo CD will take care of updating the projects in Kubernetes.\nThe main features of Argo CD include:\nAutomated deployment: When new commits are made to the tracked branch in the Git repository, Argo CD automatically deploys these changes to Kubernetes. Multi-environment management: Argo CD can manage multiple Kubernetes environments, from development (dev) and testing (staging) to production (production). Health and Integrity Checks: It can automatically check the \u0026ldquo;health\u0026rdquo; of the application after deployment and ensure integrity over time. Rollback \u0026amp; Rollout: Supports easily going back to previous versions or rolling out new updates in sequence. "
},
{
	"uri": "//localhost:1313/3-shopapp/3.3-java-spring-boot-backendp2/",
	"title": "Java Spring Boot backend (p2)",
	"tags": [],
	"description": "",
	"content": "Java Spring Boot backend (P2) Tạo bảng "
},
{
	"uri": "//localhost:1313/3-shopapp/",
	"title": "SHOP APP",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/4-java_core/",
	"title": "Java Core ",
	"tags": [],
	"description": "",
	"content": "Java Core Theory Java Core là nền tảng cốt lõi của ngôn ngữ lập trình Java. Các khái niệm cơ bản và thành phần chính của Java bao gồm cú pháp cơ bản, lớp, đối tượng, kế thừa, đa hình, xử lý ngoại lệ, và các khái niệm hướng đối tượng khác. Java Core giúp lập trình viên hiểu sâu hơn về cơ cấu và cách hoạt động của ngôn ngữ Java.\n1. Lớp và Đối Tượng (Class \u0026amp; Object) Lớp (Class) là một bản thiết kế (blueprint) từ đó các đối tượng được tạo ra. Nó chứa các thuộc tínhvà phương thức mô tả hành vi của đối tượng. Đối tượng (Object) là một thực thể cụ thể của lớp. Một đối tượng có trạng thái (biến) và hành vi (phương thức). Ví dụ:\nclass Animal { String name; int age; void sound() { System.out.println(name + \u0026#34; makes a sound\u0026#34;); } } public class Main { public static void main(String[] args) { Animal dog = new Animal(); dog.name = \u0026#34;Dog\u0026#34;; dog.age = 5; dog.sound(); // Output: Dog makes a sound } } 2. Kế Thừa (Inheritance) Kế thừa là một tính năng cho phép một lớp con (subclass) thừa hưởng các thuộc tính và phương thức từ lớp cha (superclass). Điều này giúp tái sử dụng mã và tăng tính linh hoạt. Ví dụ class Animal { void sound() { System.out.println(\u0026#34;Animal makes a sound\u0026#34;); } } class Dog extends Animal { @Override void sound() { System.out.println(\u0026#34;Dog barks\u0026#34;); } } public class Main { public static void main(String[] args) { Dog dog = new Dog(); dog.sound(); // Output: Dog barks } } 3. Đa hình (Polymorphism) Đa hình cho phép một hành động có thể được thực hiện theo nhiều cách khác nhau. Trong Java, điều này có thể đạt được thông qua ghi đè phương thức (method overriding) và nạp chồng phương thức (method overloading). Ví Dụ Tính Đa Hình Trong Thực Tế : Mình có 2 con vật, khi nhận mệnh lệnh kêu thì chó sẽ kêu \u0026ldquo;gâu gâu\u0026rdquo; con mèo sẽ kêu \u0026ldquo;meo meo\u0026rdquo;. Thì 2 con vật trên đều được nhận mệnh lệnh là hãy kêu nx mà thực hiện theo cách của chúng\nVí Dụ class Animal { void sound() { System.out.println(\u0026#34;Animal makes a sound\u0026#34;); } } class Cat extends Animal { @Override void sound() { System.out.println(\u0026#34;Cat meows\u0026#34;); } } public class Main { public static void main(String[] args) { Animal animal = new Cat(); animal.sound(); // Output: Cat meows } } 4. Tính đóng gói (Encapsulation) Tính đóng gói (Encapsulation) là một nguyên tắc trong lập trình hướng đối tượng, cho phép ẩn thông tin của đối tượng và chỉ cho phép các phương thức trong lớp đó truy cập vào các thuộc tính. Điều này giúp bảo vệ dữ liệu khỏi sự can thiệp trực tiếp từ bên ngoài và giảm sự phụ thuộc giữa các đối tượng.\nTrong Java, tính đóng gói được thực hiện bằng cách sử dụng các từ khóa truy cập như defaut, public, private, và protected để điều khiển quyền truy cập vào các biến và phương thức.\nVí Dụ\nclass Person { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } 5.Tính Trừu Tượng (Abstract Class) Tính trừu tượng (Abstract Class) là một lớp không thể tạo đối tượng trực tiếp và có thể chứa các phương thức trừu tượng (abstract methods) và các phương thức thông thường. Tính trừu tượng thể hiện trong Java Bạn có thể đạt được trừu tượng thông qua hai cơ chế chính:\nAbstract class trong Java (Lớp trừu tượng) giúp đạt được tính trừu tượng từ 0 đến 100%. Interfaces trong Java (giao diện) giúp đạt tính trừu tượng đến 100%. abstract class Shape { protected int x, y; public Shape(int x, int y) { this.x = x; this.y = y; } public abstract void draw(); } class Circle extends Shape { private int radius; public Circle(int x, int y, int radius) { super(x, y); this.radius = radius; } @Override public void draw() { System.out.println(\u0026#34;Drawing a circle at (\u0026#34; + x + \u0026#34;, \u0026#34; + y + \u0026#34;) with radius \u0026#34; + radius); } } 5.1 (Interface) Interface : Interface là một dạng lớp trừu tượng (abstract class) mà tất cả các phương thức đều là phương thức trừu tượng. Lớp kế thừa interface phải thực thi toàn bộ các phương thức của nó. Interface không phải là 1 lớp(class) mà nó chỉ chứ các phuơng thức để các class khác implement nó interface Animal { void sound(); } class Dog implements Animal { @Override public void sound() { System.out.println(\u0026#34;Dog barks\u0026#34;); } } public class Main { public static void main(String[] args) { Animal dog = new Dog(); dog.sound(); // Output: Dog barks } } Nếu là class thường thì phải implement lại tất cả các phương thức của class interface Nếu là class abtract class thì không cần phải implement của tất cả class interface interface HinhDang { void ve(); // Phương thức trừu tượng void xoa(); // Phương thức trừu tượng } class HinhTron implements HinhDang { @Override public void ve() { System.out.println(\u0026#34;Vẽ hình tròn\u0026#34;); } @Override public void xoa() { System.out.println(\u0026#34;Xóa hình tròn\u0026#34;); } } interface HinhDang { void ve(); // Phương thức trừu tượng void xoa(); // Phương thức trừu tượng } abstract class Hinh implements HinhDang { @Override public void ve() { System.out.println(\u0026#34;Vẽ hình\u0026#34;); } // Phương thức xoa() không được triển khai trong lớp trừu tượng này } class HinhVuong extends Hinh { @Override public void xoa() { System.out.println(\u0026#34;Xóa hình vuông\u0026#34;); } } So Sánh interface và abtract class Abtract Class Interface Abtract Class có phương thức abtract (không có thân hàm) và phương thúc non-abtract(có thân hàm) interface có phương thức abtract,defaut và static Không hỗ trợ tính đa kế thừa Có hỗ trợ tính đa kế thừa Có các biến final,non-final,static và non-static Chỉ có tính final và static Có thể cung cấp nôij dung cài đặt cho interface Không thể cung cấp nd cài đặt cho abtract Ví Dụ : public abtract class Shape public abtract void draw(); Ví Dụ : public interface Drawable void draw(); Map\u0026lt;String, String\u0026gt; errors= new HashMap\u0026lt;\u0026gt;(); "
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/",
	"title": "Implementing CI/CD using Jenkins and Argo CD.",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]