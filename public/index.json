[
{
	"uri": "//localhost:1313/2-git/2.1-gitbasic/",
	"title": "Basic Git repository",
	"tags": [],
	"description": "",
	"content": "Theory GitHub Basics Introduction to Git and GitHub Git is a free and open-source distributed version control system.\nGitHub is a code hosting platform for version control and collaboration.\nBasic Git Concepts Version Control:\nTracks changes to the source code.\nStores different versions of the code.\nAllows rollback to old versions for inspection and bug fixes.\n2Repository (Repo):\nA place where all files and the history of changes are stored.\nCan be stored locally or on services like GitHub.\nBasic Git Commands git init: Initialize a new repository.\ngit add \u0026lt;file\u0026gt;: Add a new file to the repository.\ngit commit -m \u0026quot;message\u0026quot;: Commit changes with a message.\ngit remote add origin \u0026lt;url\u0026gt;: Add a remote repository.\ngit push origin \u0026lt;branch\u0026gt;: Push commits to the remote repository.\ngit pull origin \u0026lt;branch\u0026gt;: Pull changes from the remote repository.\ngit status: Check the status of the repository.\ngit log: View commit history.\nUsing GitHub Pull source code from thanhvivuu.GitHub\nStep 1 : Clone the repository Open terminal :\ngit clone https://github.com/QuangThanhG13/thanhvivuu.github.io Step 2 : Change to the directory cd : thanhvuu.github.io Step 3 : Create a new Branch (Optional) If you want to work on a new feature or make changes without affecting the existing code, create a new(Khong anh hg den code cu) branch to isolate your work git checkout -b new-feature-branch Step 4 Check the Status git status Step 5 :Stage the Changes Add the modified files git add . Or add specific files git add path/to/file Step 6 : commit the changes git commit -m \u0026#34;massage\u0026#34; Step 7 : Push the changes git push origin main if you\u0026rsquo;re using a new branch: git push origin new-branch-name "
},
{
	"uri": "//localhost:1313/1-introduce/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Introduction to CI/CD, Jenkins and ArgoCD CI/CD stands for Continuous Integration/Continuous Delivery or Continuous Deployment. This is a software development approach aimed at automating the integration, testing, delivery, and deployment processes of applications.\nCI/CD continuously tests new code commits. This helps to prevent errors in the system before the new code is updated on the server. Regular integration and testing help identify and fix errors early, avoiding major problems in later stages. CI/CD automates the development and deployment processes, helping teams accelerate the release of new products.\nPopular tools that support CI/CD include Jenkins, GitLab CI, Travis CI, CircleCI, and ArgoCD for Kubernetes. Typically, what is used the most is:\nJenkins: an open-source tool that automates software development tasks such as build, test, and deploy. ArgoCD is a continuous orchestration tool for Kubernetes, helping to automate the deployment of applications in microservices architecture and manage multiple Kubernetes environments consistently. This approach not only improves team performance but also enables your product to reach users more quickly and with higher quality. In the cloud computing environment, developers often use Docker to package and Kubernetes to orchestrate.\nContents The CI/CD operations process Jenkins ArgoCD In the following sections, we will delve into the fundamental concepts of CI/CD, Jenkins and ArgoCD.\n"
},
{
	"uri": "//localhost:1313/1-introduce/1.1-cicdprocess/",
	"title": "The CI/CD operations process",
	"tags": [],
	"description": "",
	"content": "The CI/CD operations process To gain a deeper understanding of how the CI/CD process works, one needs to grasp the specific steps involved. So what do these steps include, and how do they function?\nContinuous Integration (CI) is the first process, where developers frequently merge their code into a common repository such as Git, multiple times a day. Each merge is often automatically built and tested to detect errors as early as possible, minimizing bug accumulation and reducing the time needed to deliver high-quality products. Continuous Delivery (CD) extends CI by ensuring that you can release a new version of the software at any time. In CD, the processes of building, testing, and preparing code for release are automated. Continuous Deployment (CD) is a further step beyond CD, where tested changes to the code are automatically released into the production environment. This ensures that any change, once verified, can be deployed automatically. The development lifecycle process along with the steps in CI/CD occur as follows:\nBuild: Create products from the source code, integrate, and detect errors. Test: Automatically examine new features and changed code. Deliver: Move tested code to a test environment, which can be automatic or after human approval. Deploy: Implement changes to the product, automatically or according to human approval. "
},
{
	"uri": "//localhost:1313/1-introduce/1.4-docker/",
	"title": "Theory Docker Project",
	"tags": [],
	"description": "",
	"content": "Theory Docker Project Introduction to Docker Docker is an open-source platform that automates the deployment Docker packages your application and all its dependencies into an image. A Docker image contains everything needed to run your application Key Concepts Containers: Containers are lightweight, portable, and run isolated processes on a shared operating system. They contain everything needed to run an application, including code, runtime, libraries, and settings. )\nImages: Images are read-only templates used to create containers. They are built from a Dockerfile and include the application code, dependencies, and the runtime environment.\nDockerfile: A Dockerfile is a script containing instructions on how to build a Docker image. It specifies the base image, application code, environment variables, and commands to run.\nDocker Hub: Docker Hub is a cloud-based repository where users can find and share Docker images. It provides a centralized place to store and manage Docker images.\nAdvantages of Docker Portability: Containers can run on any system with Docker installed, ensuring consistent behavior across development, testing, and production environments. Efficiency: Containers share the host system\u0026rsquo;s kernel, making them more lightweight and efficient compared to virtual machines. Scalability: Docker enables easy scaling of applications by deploying multiple containers across various environments. Isolation: Containers run in isolated environments, preventing conflicts between applications and enhancing security. Docker Architecture Docker Engine: The core component of Docker, responsible for creating and managing containers. It consists of:\nDocker Daemon: The background service running on the host machine that manages Docker objects (images, containers, networks, volumes). Docker CLI: The command-line interface used to interact with the Docker Daemon. Docker Objects:\nImages: Immutable files used to create containers. Containers: Running instances of images that can be started, stopped, moved, and deleted. Networks: Enable communication between Docker containers. Volumes: Provide persistent storage for containers. Basic Docker Commands docker run: Create and start a new container from an image. docker build: Build an image from a Dockerfile. docker pull: Download an image from a registry. docker push: Upload an image to a registry. docker ps: List running containers. docker stop: Stop a running container. docker rm: Remove a container. docker rmi: Remove an image. Example: Creating a Docker Image Here\u0026rsquo;s an example of a simple Dockerfile to create a Docker image for a Python application:\n# Use the official Python base image FROM python:3.8-slim # Set the working directory WORKDIR /app # Copy the current directory contents into the container COPY . /app # Install any needed packages specified in requirements.txt RUN pip install --no-cache-dir -r requirements.txt # Make port 80 available to the world outside this container EXPOSE 80 # Define the command to run the application CMD [\u0026#34;python\u0026#34;, \u0026#34;app.py\u0026#34;] "
},
{
	"uri": "//localhost:1313/2-git/2.2-advancedgit/",
	"title": "Advanced Git",
	"tags": [],
	"description": "",
	"content": "Advanced Git 1. Advanced Branching and Merging Branching Strategy: Branching strategies like Git Flow, GitHub Flow, and Trunk-based Development help organize and manage the development process. Rebase: Used to move or combine a series of commits from one branch to another. Rebase makes the commit history cleaner by removing unnecessary merge commits. Cherry-pick: Selectively apply a commit from one branch to another without merging the entire branch. Merge Conflicts: How to resolve merge conflicts and use tools like git mergetool. 2. Advanced Git Commands and Usage Stash: Save unfinished changes without committing them, allowing you to switch to other tasks. Use git stash apply or git stash pop to restore stashed changes. Bisect: Locate bugs by bisecting the commit range to find the offending commit. Filter-branch and BFG: Modify commit history, such as removing large files or sensitive information that was previously committed. 3. Git Hooks Git hooks are scripts that execute automatically when certain events occur in Git, such as commit, push, or merge. Common hooks include:\nPre-commit: Check the source code before committing. Pre-push: Validate or execute actions before pushing to a remote. Post-checkout: Execute after a new branch is checked out. 4. Managing Large Repositories and Advanced Techniques Shallow Clone: Clone a repository with limited depth to reduce time and storage space. Sparse Checkout: Allows downloading only a portion of the repository, useful for projects with large directory structures. Large File Storage (LFS): Used to manage large binary files that Git doesn\u0026rsquo;t handle well. 5. Security and Access Control GPG Commit Signing: Sign commits to ensure authenticity. Access Control: Manage repository access permissions through platforms like GitHub, GitLab, or Bitbucket. 6. Performance Optimization Garbage Collection: Use git gc to clean up and optimize storage space. Submodules: Manage sub-repositories within a main repository. Subtree: An alternative to submodules, allowing the management of code from external repositories. 7. External Tools and Utilities Git GUI Tools: Graphical interface tools like SourceTree, GitKraken, and GitHub Desktop help manage repositories and workflows more easily. Continuous Integration (CI): Integrate Git with CI/CD services like Jenkins, GitLab CI, and GitHub Actions to automate testing and deployment. 8. Best Practices Commit Messages: Write clear and meaningful commit messages. Branch Naming Conventions: Use branch naming conventions for easy management and tracking. Code Reviews: Conduct code reviews before merging into the main branch. "
},
{
	"uri": "//localhost:1313/2-git/2.2-advancedgit/_index1/",
	"title": "GH flow",
	"tags": [],
	"description": "",
	"content": "Examples of Branching Strategies 1. Git Flow Example Scenario: A development team is preparing to release version 1.0 of an application.\nMain Branch (main): Contains the stable, released version of the application.\nDevelop Branch (develop): Contains the latest development changes for the next release.\nSteps:\nFeature Branches:\nfeature/user-authentication: A developer creates this branch from develop to add user authentication functionality.\nfeature/payment-integration: Another developer creates this branch from develop to add payment integration.\nMerging Features:\nAfter completing and testing features, they are merged into develop. Release Branch:\nWhen features are ready for release, a release/1.0 branch is created from develop. This branch is used for final bug fixes and release preparation.\nOnce ready, release/1.0 is merged into both main and develop, updating the official release and ensuring bug fixes are also in the development branch.\nHotfix Branch:\nIf an urgent issue needs fixing in version 1.0, a hotfix/1.0.1 branch is created from main, the issue is fixed, and the branch is merged into both main and develop. 2. GitHub Flow Example Scenario: A development team is adding an \u0026ldquo;About Us\u0026rdquo; page to the company\u0026rsquo;s website.\nSteps:\nCreate a Branch:\nA developer creates the add-about-page branch from main to work on the \u0026ldquo;About Us\u0026rdquo; page. Make Changes:\nOn the add-about-page branch, the developer adds HTML and CSS files for the \u0026ldquo;About Us\u0026rdquo; page. Each significant change is committed and pushed with descriptive messages like add initial about page content and style about page. Create a Pull Request:\nUpon completion, the developer creates a pull request from add-about-page to main, describing the changes and their purpose. They also link the pull request to a relevant issue. Review and Feedback:\nColleagues review the pull request, leaving comments or suggestions. The developer may make additional commits to address the feedback. Merge and Deploy:\nOnce the pull request is approved, it is merged into main, and the changes are deployed to the website. Delete the Branch:\nAfter merging, the add-about-page branch is deleted to avoid confusion with other ongoing work. 3. Trunk-Based Development Example Scenario: A company continuously develops a web application with frequent feature additions.\nSteps:\nDirect Commits to Trunk (main):\nAll developers work directly on the main branch, committing small, frequent changes. Short-lived Feature Branches:\nIf necessary, developers can create short-lived feature branches (e.g., feature/update-dashboard) for complex features but must complete and merge them back into main quickly. Continuous Integration:\nEach commit to main triggers an automatic CI process, running tests and deploying changes if all tests pass. Feature Flags:\nIncomplete new features are hidden behind feature flags, allowing them to be deployed without impacting users. Summary:\nIn Trunk-Based Development, the main branch is always kept stable and deployable. Features and bug fixes are integrated continuously and quickly.\n"
},
{
	"uri": "//localhost:1313/2-git/2.2-advancedgit/_index2/",
	"title": "GibHub homework",
	"tags": [],
	"description": "",
	"content": "Advanced Exercise: Project Management with Git Step 1: Install Git Go to git-scm.com. Download and install Git following the instructions for your operating system. Step 2: Configure Git Open the terminal (or Command Prompt on Windows). Configure your name and email with the following commands: git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;email@example.com\u0026#34; Step 3: Initialize a Repository Create a new directory and move into it: mkdir AdvancedGitProject cd AdvancedGitProject Initial a git repository git init git init is used to initialize a new Git repository Creates a .git Directory Prepares the Project for Version Control : Flow the changes from the Sets Up the Initial Branch: By default, git init \u0026ndash;\u0026gt; creates a new branch called main Step 4: Add and Commit Changes Create a README.md file and add a description: echo \u0026#34;# AdvancedGitProject\u0026#34; \u0026gt;\u0026gt; README.md Add and commit the changes: git add README.md git commit -m \u0026#34;Add README file\u0026#34; Step 5: Create a New Branch and Use Rebase Create and switch to a new branch: git checkout -b feature-branch 2. Create a feature.txt file, add content, and commit the changes\necho \u0026#34;This is a new feature\u0026#34; \u0026gt;\u0026gt; feature.txt git add feature.txt 3. Switch back to the main branch\ngit checkout main Create a hotfix.txt file, add content, and commit the changes: echo \u0026#34;This is a hotfix\u0026#34; \u0026gt;\u0026gt; hotfix.txt git add hotfix.txt git commit -m \u0026#34;Add hotfix.txt\u0026#34; Maventool 5.Rebase the feature-branch onto the main branch:\ngit checkout feature-branch git rebase main git rebase main: Rebase nhánh feature-branch lên nhánh main có nghĩa là: Lấy tất cả các commit từ nhánh feature-branch và áp dụng chúng lên đỉnh của nhánh main. Cập nhật nhánh feature-branch với các thay đổi mới nhất từ nhánh main. Đảm bảo rằng các thay đổi trên nhánh feature-branch được áp dụng sau các thay đổi trên nhánh main, giúp lịch sử commit của nhánh feature-branch trở nên đồng bộ với nhánh main. -Create files here Nghĩa là sẽ lấy commit từ nhanh feature-branch này cập nhập vào nhánh main. Step 6: User Cherry picks Create a new commit on the main branch git checkout main echo \u0026#34;Another fix\u0026#34; \u0026gt;\u0026gt; anotherfix.txt git add anotherfix.txt git commit -m \u0026#34;Add anotherfix.txt\u0026#34; Cherry-pick this commit onto the feature-branch: git checkout feature-branch git cherry-pick \u0026lt;commit-hash\u0026gt; Trong hình cho ta thấy git cherry-pick ed7bb320f46b3b3842174c661c88e2e3ab120ded dùng để chọn và áp dụng một commit từ một nhánh khác vào nhánh hiện tại. tôi đã tạo file anotherfix.text ở nhanh main và sử dụng git cherry-pick ... để chuyển sang nhánh feature Step 7: Use Stash Make some changes on the feature-branch that you don\u0026rsquo;t want to commit yet echo \u0026#34;Some temporary changes\u0026#34; \u0026gt;\u0026gt; temp.txt Stash the changes: git stash Perform other tasks: git checkout main echo \u0026#34;Work on another task\u0026#34; \u0026gt;\u0026gt; another_task.txt git add another_task.txt git commit -m \u0026#34;Work on another task\u0026#34; Retrieve the changes from the stash git checkout feature-branch git stash pop Nếu mình chưa muốn commit vào file thì sử dụng git stash git stash: Lưu trữ các thay đổi chưa được commit để quay lại làm việc sau. git stash pop: Lấy lại các thay đổi từ stash và áp dụng chúng lên nhánh hiện tại. git stash list: Xem danh sách các mục stash hiện có. Step 8 : Use Submodule Add a submodule to your project (e.g., add a repository from GitHub): git submodule add \u0026lt;repository-url\u0026gt; Step 9: Push to GitHub Push your changes to GitHub git remote add origin \u0026lt;repository-url\u0026gt; git branch -M main git push -u origin main "
},
{
	"uri": "//localhost:1313/2-git/",
	"title": "GitHub",
	"tags": [],
	"description": "",
	"content": "\n"
},
{
	"uri": "//localhost:1313/1-introduce/1.2-jenkins/",
	"title": "Jenkins",
	"tags": [],
	"description": "",
	"content": "Jenkins Jenkins is an open-source automation tool that helps to automate various parts of the software development process such as building, testing, and deploying applications. It supports Continuous Integration (CI) and Continuous Delivery (CD).\nYou can use Amazon Elastic Compute Cloud (Amazon EC2) to deploy a Jenkins application on AWS in a matter of minutes.\nThis tutorial walks you through the process of deploying a Jenkins application. You will launch an EC2 instance, install and configure Jenkins on that instance.\n"
},
{
	"uri": "//localhost:1313/1-introduce/1.3-argocd/",
	"title": "Argo CD",
	"tags": [],
	"description": "",
	"content": "Argo CD Argo CD is an open-source project designed to provide automated deployment for Kubernetes projects. It follows the \u0026ldquo;GitOps\u0026rdquo; principle, automatically synchronizing Kubernetes projects to match the source code in the git repository. Simply commit changes to git, and Argo CD will take care of updating the projects in Kubernetes.\nThe main features of Argo CD include:\nAutomated deployment: When new commits are made to the tracked branch in the Git repository, Argo CD automatically deploys these changes to Kubernetes. Multi-environment management: Argo CD can manage multiple Kubernetes environments, from development (dev) and testing (staging) to production (production). Health and Integrity Checks: It can automatically check the \u0026ldquo;health\u0026rdquo; of the application after deployment and ensure integrity over time. Rollback \u0026amp; Rollout: Supports easily going back to previous versions or rolling out new updates in sequence. "
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/",
	"title": "Implementing CI/CD using Jenkins and Argo CD.",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]